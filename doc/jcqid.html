<!DOCTYPE html>
<!-- Auto-generated by Bark -->
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Jacques-ID specification</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link href="SourceFonts.css" rel="stylesheet"/>
    <style>

body {
  max-width: 35em;
  padding-left: 0.25em;
  padding-right: 0.25em;
  margin-left: auto;
  margin-right: auto;
  margin-bottom: 3.5em;
  font-family: 'Source Serif', serif;
  background-color: WhiteSmoke;
  color: black;
}

:link {
  text-decoration: none;
  color: blue
}

:visited {
  text-decoration: none;
  color: blue
}

.tt {
  font-family: 'Source Code Pro', monospace;
  background-color: LightGray;
}

hr {
  margin-top: 2.5em;
}

#toc {
  background-color: white;
  padding: 0.5em;
  border: thin solid;
  margin-bottom: 1.5em;
  font-family: 'Source Sans 3', sans-serif;
}

#tochead {
  text-align: center;
  font-weight: bold;
  margin-bottom: 1em;
}

#toc ul {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 1.5em;
  padding-right: 1.5em;
}

h1 {
  font-family: 'Source Sans 3', sans-serif;
  margin-bottom: 0;
  text-align: center;
}

#verline {
  font-family: 'Source Sans 3', sans-serif;
  font-size: 150%;
  text-align: center;
}

h2 {
  font-family: 'Source Sans 3', sans-serif;
}

h3 {
  font-family: 'Source Sans 3', sans-serif;
}

h4 {
  font-family: 'Source Sans 3', sans-serif;
}

li {
  font-family: 'Source Sans 3', sans-serif;
}

#footline {
  font-size: smaller;
  text-align: right;
}

.iblock {
  font-family: 'Source Sans 3', sans-serif;
}

.explain {
  font-size: smaller;
}

.comment {
  color: DarkSlateGray;
}

.cblock {
  background-color: white;
  color: indigo;
  padding: 0.5em;
  font-family: 'Source Code Pro', monospace;
  border: thin dotted;
  overflow: auto;
}

.chead {
  text-decoration: underline;
  margin-top: 1em;
  margin-bottom: 1em;
}

.chead:first-child {
  margin-top: 0;
}

.ci {
  margin-left: 2em;
  margin-top: 1em;
}

#titlebox {
  background-color: white;
  margin-top: 3em;
  margin-bottom: 3em;
  padding-top: 0.5em;
  padding-bottom: 1.5em;
  border: medium double;
}

#syt table {
  border-collapse: collapse;
}

#syt th {
  border: thin solid;
  padding-left: 0.5em;
  padding-right: 0.5em;
  text-align: center;
  font-family: 'Source Sans 3', sans-serif;
}

#syt td {
  border: thin solid;
  padding-left: 0.5em;
  padding-right: 0.5em;
  text-align: center;
  font-family: 'Source Code Pro', monospace;
}

#syt .nc {
  font-family: 'Source Sans 3', sans-serif;
}

#ptable table {
  border-collapse: collapse;
}

#ptable td {
  padding-left: 0.5em;
  padding-right: 0.5em;
  text-align: right;
  font-family: 'Source Sans 3', sans-serif;
}

    </style>
  </head>
  <body>

<div id="titlebox">
<h1>Jacques-ID specification</h1>
<div id="verline">Version 1.0</div>
</div>

<div id="toc">
<div id="tochead">Table of Contents</div>
<ul>
  <li>1. <a href="#sec1">Introduction</a></li>
  <li>2. <a href="#sec2">Numeric format</a>
    <ul>
      <li>2.1 <a href="#sec2p1">Hour count and fallback mode</a></li>
      <li>2.2 <a href="#sec2p2">Division count</a></li>
      <li>2.3 <a href="#sec2p3">Second count</a></li>
      <li>2.4 <a href="#sec2p4">Random portion</a></li>
    </ul>
  </li>
  <li>3. <a href="#sec3">ID format</a>
    <ul>
      <li>3.1 <a href="#sec3p1">ID normalization</a></li>
    </ul>
  </li>
  <li>4. <a href="#sec4">Generation algorithm</a>
    <ul>
      <li>4.1 <a href="#sec4p1">Regular generation</a></li>
      <li>4.2 <a href="#sec4p2">Fallback generation</a></li>
    </ul>
  </li>
  <li>5. <a href="#sec5">Library documentation</a>
    <ul>
      <li>5.1 <a href="#sec5p1">ID generation</a></li>
      <li>5.2 <a href="#sec5p2">ID retirement</a></li>
      <li>5.3 <a href="#sec5p3">ID handling</a></li>
    </ul>
  </li>
</ul>
<div> </div>
<ul>
  <li>A. <a href="#secA">External references</a></li>
  <li>B. <a href="#secB">Building the specification</a></li>
  <li>C. <a href="#secC">Specification license</a></li>
</ul>
</div>

<h2 id="sec1">1. Introduction</h2>

<p>Jacques-ID is a system for generating unique identification numbers consisting of eight base-64 digits, using a combination of random and time-​based processes.</p>

<p>ID codes generated by this module are intended for use as permanent identification numbers.  Jacques-ID codes have the following advantages compared to other identification number systems:</p>

<p><b>Jacques-ID versus auto-​incrementing primary keys:</b></p>

<ul>
<li>Jacques-ID is completely independent from the physical layout of the data table</li>
<li>No need to worry about deleted Jacques-ID codes being accidentally reused in future</li>
<li>Canʼt guess total number of records in table from a Jacques-ID code</li>
<li>Much more difficult to guess the Jacques-ID codes of table records</li>
</ul>

<p><b>Jacques-ID versus completely random ID codes:</b></p>

<ul>
<li>Jacques-ID can guarantee that ID codes will never be accidentally reused in the future</li>
<li>Jacques-ID can provide guarantees against collisions during generation</li>
</ul>

<p>The guarantee that Jacques-ID codes will never be reused in the future is an important advantage over both auto-​incrementing primary keys and complete random ID codes.  This guarantee means that when identified objects are deleted, there is no need to keep track of deleted ID codes to prevent their reuse.</p>

<p>(However, this guarantee can only be made when the system clock is operating correctly.  This is because Jacques-ID depends on correct timer values to enforce its uniqueness guarantees.)</p>

<h2 id="sec2">2. Numeric format</h2>

<p>The <i>numeric format</i> of a Jacques-ID code refers to the numeric value of the Jacques-ID code before it is encoded into base-64 digits.  A Jacques-ID numeric value is an unsigned binary integer of exactly 48 bits, so that when encoded into base-64 digits, it will result in exactly eight base-64 digits with no need for padding.</p>

<p>The structure of the Jacques-ID numeric format is as follows, ordered from most significant bits to least significant bits:</p>

<ol>
<li><b>11 bits:</b> (pseudo-)​random bits
<li><b>8 bits:</b> seconds within the division</li>
<li><b>4 bits:</b> divisions within the hour</li>
<li><b>25 bits:</b> hours since Unix epoch</li>
</ol>

<p>The client does not actually need to know about this numeric format, but it is documented here for completeness.  The following subsections describe the parts of the numeric format in further detail.</p>

<h3 id="sec2p1">2.1 Hour count and fallback mode</h3>

<p>The 25 least significant bits of the Jacques-ID numeric format counts the number of <i>hours</i> that have elapsed since the Unix epoch on midnight GMT at the start of January 1, 1970.  This hour counter will not overflow until about the Gregorian year 5797.  Jacques-ID is therefore not subject to the “Year 2038 problem,” <a href="#extP2038">[P-2038]</a>.</p>

<p>To handle the theoretical case that Jacques-ID is still used in the year 5797, and the more likely case that something is wrong with the system timer, Jacques-ID has a <i>fallback mode</i> that is used when the time value is out of range.</p>

<p>Specifically, the fallback mode is used when the hour count would overflow (in the year 5797 and beyond), and when the hour count is less than 262,968, which would imply that the current year is less than Gregorian year 2000, which canʼt be right because Jacques-ID was first defined in 2021.  If either of these cases occur in practice, the likely explanation is that there is a problem with the system clock.</p>

<p>In fallback mode, the hour count is set to a random value that in range [0, 262,967], and the 23 most significant bits of the numeric ID value are set randomly.  ID numbers generated in fallback mode will never collide with ID numbers generated using the regular Jacques-ID process, because fallback mode limits the values in the hour count to values that are never used in regular operation.</p>

<p>However, Jacques-ID is no longer able to guarantee that ID numbers will never be reused when operating in fallback mode.  Fortunately, fallback mode should never be necessary when the system clock is operating correctly.</p>

<h3 id="sec2p2">2.2 Division count</h3>

<p>The <i>division count</i> is the number of hour-​divisions that have elapsed within the hour defined by the <a href="#sec2p1">hour count</a> (§2.1).</p>

<p>An <i>hour-​division</i> is defined as 3 minutes and 45 seconds, which is exactly 1/16 of a hour.  Since four bits are assigned in the <a href="#sec2">numeric format</a> (§2) to the hour-​division, the hour-​division count uses the full range of binary values, from zero up to and including 15.</p>

<p>If <a href="#sec2p1">fallback mode</a> (§2.1) is used, the division count is set to random bits.</p>

<h3 id="sec2p3">2.3 Second count</h3>

<p>The <i>second count</i> is the number of seconds that have elapsed within the hour-​division defined by the <a href="#sec2p2">division count</a> (§2.2).</p>

<p>Since each hour-​division is 3 minutes and 45 seconds, there are a total of 225 seconds in each hour-​division.  The eight bits assigned to the second count in the <a href="#sec2">numeric format</a> (§2) allow for a total range of 256 values.  Of this total range, [0, 224] is used for the second count while [225, 255] is reserved and not used in practice.</p>

<p>If <a href="#sec2p1">fallback mode</a> (§2.1) is used, the second count is set to random bits.  The reserved values in range [225, 255] may be used in fallback mode.</p>

<h3 id="sec2p4">2.4 Random portion</h3>

<p>The 11 most significant bits of the numeric value of a Jacques-ID code are always (pseudo-)​randomly chosen using a cryptographically secure source of randomness.</p>

<p>The 11 random bits allow for 2,048 different ID codes to be generated each second.</p>

<h2 id="sec3">3. ID format</h2>

<p>Once the 48 bits of the <a href="#sec2">numeric value</a> (§2) of the ID code have been decided, the numeric value is encoded into base-64 to yield the 8-character ID code.</p>

<p>The base-64 digits use the following US-ASCII characters, in the order given below:</p>

<ol>
<li>26 uppercase letters A-Z</li>
<li>26 lowercase letters a-z</li>
<li>10 decimal digits 0-9</li>
<li>Two extra symbols <i>(see below)</i></li>
</ol>

<p>There is no need for a padding character, because the 48 bits of the numeric value fit into exactly eight base-64 digits.</p>

<p>The two extra symbols vary by context.  There is a <i>standard</i> set of symbols, and a <i>URL-safe</i> set of symbols.  The following table shows the base-64 digits for the last two values 62 and 63 in the standard and URL-safe symbol sets:</p>

<blockquote id="syt">
<table>
  <tr>
    <th>Digit value</th>
    <th>Standard digit</th>
    <th>URL-safe digit</th>
  </tr>
  <tr><td class="nc">62</td><td>+</td><td>-</td></tr>
  <tr><td class="nc">63</td><td>/</td><td>_</td></tr>
</table>
</blockquote>

<p>The standard digits are the normal form, because they are easier to visually distinguish.  The URL-​safe digits are safer to use because the hyphen and underscore are less likely to be misinterpreted as special characters, but they are less visually distinct.</p>

<h3 id="sec3p1">3.1 ID normalization</h3>

<p>Normalizing a Jacques-ID is accomplished by trimming leading and trailing whitespace, and then replacing any URL-​safe extra symbols with their standard extra symbol equivalents.  See §3 <a href="#sec3">ID format</a> for the equivalencies between URL-​safe and standard extra symbols.</p>

<p>A normalized Jacques-ID must consist of exactly eight base-64 characters to be valid.  Jacques-ID codes are considered valid even if they use the reserved values of the <a href="#sec2p3">second count</a> (§2.3) field outside of fallback mode.</p>

<h2 id="sec4">4. Generation algorithm</h2>

<p>The <i>generation algorithm</i> specifies how a Jacques-ID is generated.  More than one ID may need to be generated to find an ID that is unique.</p>

<p>Generation is handled by a generator object instance.  When this generator object instance is constructed, it either uses the current time to determine the value of the 37 least significant bits of the <a href="#sec2">numeric value</a> (§2), or it sets an internal flag indicating that <a href="#sec2p1">fallback mode</a> (§2.1) is in use because something is wrong with the system timer.</p>

<p>During construction, the generator object will also start the attempt counter out at zero.  Up to 2,048 attempts can be made to find a unique ID.  If a unique ID canʼt be found within that many attempts, ID generation fails.</p>

<h3 id="sec4p1">4.1 Regular generation</h3>

<p>The regular generation system is used for generator objects that were <i>not</i> constructed in fallback mode.  The objects will have an attempt counter set to zero and already have the 37 least significant bits of the <a href="#sec2">numeric value</a> (§2) determined, as explained in §4 <a href="#sec4">Generation algorithm</a>.  Regular generation simply has to determine the 11 most significant bits of the numeric value, which are the <a href="#sec2p4">random portion</a> (§2.4).</p>

<p>To determine the random portion, the generator object chooses a random value in range [0, 2047] and also a random prime number that is greater than 2 and less than 2048.  The following table is a comprehensive list of all such prime numbers, derived from <a href="#extPrimes">[PRIMES]</a>:</p>

<blockquote id="ptable">
<table>
  <tr><td>3</td><td>5</td><td>7</td><td>11</td><td>13</td><td>17</td><td>19</td><td>23</td><td>29</td><td>31</td></tr>
  <tr><td>37</td><td>41</td><td>43</td><td>47</td><td>53</td><td>59</td><td>61</td><td>67</td><td>71</td><td>73</td></tr>
  <tr><td>79</td><td>83</td><td>89</td><td>97</td><td>101</td><td>103</td><td>107</td><td>109</td><td>113</td><td>127</td></tr>
  <tr><td>131</td><td>137</td><td>139</td><td>149</td><td>151</td><td>157</td><td>163</td><td>167</td><td>173</td><td>179</td></tr>
  <tr><td>181</td><td>191</td><td>193</td><td>197</td><td>199</td><td>211</td><td>223</td><td>227</td><td>229</td><td>233</td></tr>
  <tr><td>239</td><td>241</td><td>251</td><td>257</td><td>263</td><td>269</td><td>271</td><td>277</td><td>281</td><td>283</td></tr>
  <tr><td>293</td><td>307</td><td>311</td><td>313</td><td>317</td><td>331</td><td>337</td><td>347</td><td>349</td><td>353</td></tr>
  <tr><td>359</td><td>367</td><td>373</td><td>379</td><td>383</td><td>389</td><td>397</td><td>401</td><td>409</td><td>419</td></tr>
  <tr><td>421</td><td>431</td><td>433</td><td>439</td><td>443</td><td>449</td><td>457</td><td>461</td><td>463</td><td>467</td></tr>
  <tr><td>479</td><td>487</td><td>491</td><td>499</td><td>503</td><td>509</td><td>521</td><td>523</td><td>541</td><td>547</td></tr>
  <tr><td>557</td><td>563</td><td>569</td><td>571</td><td>577</td><td>587</td><td>593</td><td>599</td><td>601</td><td>607</td></tr>
  <tr><td>613</td><td>617</td><td>619</td><td>631</td><td>641</td><td>643</td><td>647</td><td>653</td><td>659</td><td>661</td></tr>
  <tr><td>673</td><td>677</td><td>683</td><td>691</td><td>701</td><td>709</td><td>719</td><td>727</td><td>733</td><td>739</td></tr>
  <tr><td>743</td><td>751</td><td>757</td><td>761</td><td>769</td><td>773</td><td>787</td><td>797</td><td>809</td><td>811</td></tr>
  <tr><td>821</td><td>823</td><td>827</td><td>829</td><td>839</td><td>853</td><td>857</td><td>859</td><td>863</td><td>877</td></tr>
  <tr><td>881</td><td>883</td><td>887</td><td>907</td><td>911</td><td>919</td><td>929</td><td>937</td><td>941</td><td>947</td></tr>
  <tr><td>953</td><td>967</td><td>971</td><td>977</td><td>983</td><td>991</td><td>997</td><td>1009</td><td>1013</td><td>1019</td></tr>
  <tr><td>1021</td><td>1031</td><td>1033</td><td>1039</td><td>1049</td><td>1051</td><td>1061</td><td>1063</td><td>1069</td><td>1087</td></tr>
  <tr><td>1091</td><td>1093</td><td>1097</td><td>1103</td><td>1109</td><td>1117</td><td>1123</td><td>1129</td><td>1151</td><td>1153</td></tr>
  <tr><td>1163</td><td>1171</td><td>1181</td><td>1187</td><td>1193</td><td>1201</td><td>1213</td><td>1217</td><td>1223</td><td>1229</td></tr>
  <tr><td>1231</td><td>1237</td><td>1249</td><td>1259</td><td>1277</td><td>1279</td><td>1283</td><td>1289</td><td>1291</td><td>1297</td></tr>
  <tr><td>1301</td><td>1303</td><td>1307</td><td>1319</td><td>1321</td><td>1327</td><td>1361</td><td>1367</td><td>1373</td><td>1381</td></tr>
  <tr><td>1399</td><td>1409</td><td>1423</td><td>1427</td><td>1429</td><td>1433</td><td>1439</td><td>1447</td><td>1451</td><td>1453</td></tr>
  <tr><td>1459</td><td>1471</td><td>1481</td><td>1483</td><td>1487</td><td>1489</td><td>1493</td><td>1499</td><td>1511</td><td>1523</td></tr>
  <tr><td>1531</td><td>1543</td><td>1549</td><td>1553</td><td>1559</td><td>1567</td><td>1571</td><td>1579</td><td>1583</td><td>1597</td></tr>
  <tr><td>1601</td><td>1607</td><td>1609</td><td>1613</td><td>1619</td><td>1621</td><td>1627</td><td>1637</td><td>1657</td><td>1663</td></tr>
  <tr><td>1667</td><td>1669</td><td>1693</td><td>1697</td><td>1699</td><td>1709</td><td>1721</td><td>1723</td><td>1733</td><td>1741</td></tr>
  <tr><td>1747</td><td>1753</td><td>1759</td><td>1777</td><td>1783</td><td>1787</td><td>1789</td><td>1801</td><td>1811</td><td>1823</td></tr>
  <tr><td>1831</td><td>1847</td><td>1861</td><td>1867</td><td>1871</td><td>1873</td><td>1877</td><td>1879</td><td>1889</td><td>1901</td></tr>
  <tr><td>1907</td><td>1913</td><td>1931</td><td>1933</td><td>1949</td><td>1951</td><td>1973</td><td>1979</td><td>1987</td><td>1993</td></tr>
  <tr><td>1997</td><td>1999</td><td>2003</td><td>2011</td><td>2017</td><td>2027</td><td>2029</td><td>2039</td><td colspan="2"></td></tr>
</table>
</blockquote>

<p>The chosen random value will be the first value used in the random portion.  Additional values are generated by adding the randomly selected prime number to the current random portion value, and then taking the result of that <i>modulo</i> 2048.  This procedure will cycle through every possible value of the random portion before generating any duplicate values (see below).  The generator object can therefore generate up to 2048 unique ID codes, after which further attempts to generate new ID codes will fail.</p>

<p>The remainder of this subsection is a proof that the generation procedure described above will always cycle through every possible value of the random portion before generating any duplicate values.</p>

<p>Let <i>p</i> be a prime number that is greater than two and less than 2048.  Suppose that there existed an integer <i>n</i> that is greater than zero but less than 2048, such that:</p>

<blockquote class="iblock">
(<i>n</i> × <i>p</i>) mod 2048 = 0<br/>
<br/>
<i>p</i> in range [3, 2047]<br/>
<i>p</i> is prime<br/>
<i>n</i> in range [1, 2047]
</blockquote>

<p>We can rewrite this equation as follows:</p>

<blockquote class="iblock">
(<i>n</i> × <i>p</i>) mod 2<sup>11</sup> = 0<br/>
<br/>
<i>p</i> in range [3, 2<sup>11</sup> - 1]<br/>
<i>p</i> is prime<br/>
<i>n</i> in range [1, 2<sup>11</sup> - 1]
</blockquote>

<p>In order for the modulus to be zero, (<i>n</i> × <i>p</i>) must be divisible by 2<sup>11</sup>.  The <i>Fundamental Theorem of Arithmetic</i> <a href="#extArith">[ARITH]</a> tells us that each integer has a unique prime number factorization.  <i>n</i> and <i>p</i> are both less than 2<sup>11</sup>, so if either one of them is not divisible by 2, then the unique prime number factorization of their product will not include 2<sup>11</sup> as a factor, which would mean that their product is not divisible by 2<sup>11</sup>.  Therefore, both <i>n</i> and <i>p</i> must be divisible by two.  But this is a contradiction, because <i>n</i> is a prime number that is greater than two, and therefore it canʼt be divisible by two.  Thus, there does not exist any integer <i>n</i> that is greater than zero but less than 2048, such that:</p>

<blockquote class="iblock">
(<i>n</i> × <i>p</i>) mod 2048 = 0<br/>
<br/>
<i>p</i> in range [3, 2047]<br/>
<i>p</i> is prime<br/>
<i>n</i> in range [1, 2047]
</blockquote>

<p>It therefore follows that:</p>

<blockquote class="iblock">
(<i>n</i> × <i>p</i>) mod 2048 != 0<br/>
for all <i>n</i> in range [1, 2047]<br/>
<br/>
<i>p</i> in range [3, 2047]<br/>
<i>p</i> is prime
</blockquote>

<p>Suppose we define a sequence <i>s</i><sub>0</sub> ... <i>s</i><sub>2047</sub> for a prime number <i>p</i> that is greater than two but less than 2048 as follows:</p>

<blockquote class="iblock">
<i>s</i><sub><i>i</i></sub> = (<i>i</i> × <i>p</i>) mod 2048
</blockquote>

<p>Then, the first element <i>s</i><sub>0</sub> of the sequence is always zero, and we know from our previous equation that all other elements in the sequence are always <i>not</i> equal to zero.</p>

<p>The sequence can be expressed equivalently in recursive fashion as:</p>

<blockquote class="iblock">
<i>s</i><sub>0</sub> = 0<br/>
<i>s</i><sub><i>i</i></sub> = (<i>s</i><sub><i>i</i> - 1</sub> + <i>p</i>) mod 2048
</blockquote>

<p>Suppose there existed a pair of integers <i>j</i> and <i>k</i> such that <i>j</i> &lt; <i>k</i>, both are in range [0, 2047], and <i>s</i><sub><i>j</i></sub> is equal to <i>s</i><sub><i>k</i></sub>.  <i>j</i> canʼt be zero, because we have shown that <i>s</i><sub>0</sub> is the only element of the sequence that is zero, so there is no other element of the sequence that it could match.  Thus, both <i>j</i> and <i>k</i> must be greater than zero.  Since <i>p</i> is less than 2048, the recursive definition of the sequence given above shows that if two elements in the sequence are the same, the elements immediately before those two elements must also be the same.  Therefore, the following equivalencies must hold:</p>

<blockquote class="iblock">
<i>s</i><sub><i>j</i></sub> = <i>s</i><sub><i>k</i></sub><br/>
<i>s</i><sub><i>j</i> - 1</sub> = <i>s</i><sub><i>k</i> - 1</sub><br/>
<i>s</i><sub><i>j</i> - 2</sub> = <i>s</i><sub><i>k</i> - 2</sub><br/>
...<br/>
<i>s</i><sub>0</sub> = <i>s</i><sub><i>k</i> - <i>j</i></sub>
</blockquote>

<p>Thus, element <i>s</i><sub>0</sub> must equal element <i>s</i><sub><i>k</i> - <i>j</i></sub> by working backwards through the recursive process.  But this is a contradiction, because we have shown that <i>s</i><sub>0</sub> is the only element in the sequence that is zero, and so it canʼt be equal to any of the other elements.  Therefore, no two elements of the sequence are alike, and therefore the sequence cycles through all possible values <i>modulo</i> 2048 before repeating anything.</p>

<p>The script <span class="tt">check_​cycles​.py</span> verifies the results of this proof by going through every prime number given in the table earlier in this section and verifying that each of them generates a <i>modulo</i>-2048 sequence without any repetition.</p>

<h3 id="sec4p2">4.2 Fallback generation</h3>

<p>The fallback generation system is used for generator objects that were constructed in fallback mode, which should only happen when there is something wrong with the system clock.  (See §2.1 <a href="#sec2p1">Hour count and fallback mode</a> for further information.)</p>

<p>Fallback generation begins by choosing a sequence of 2048 random but unique values in the reserved hour count range [0, 262,967].  This determines the hour count value for each of the generated fallback IDs, and guarantees that each ID generated by the generator object is unique.</p>

<p>Each ID in fallback mode is generated by stepping through the list of 2048 randomly generated hour count values, and for each of them setting all the remaining bits to random values to complete the ID code.  The fallback generator fails to generate more IDs after 2048 have been generated, so it functions the same way as regular generation from the perspective of the client.</p>

<h2 id="sec5">5. Library documentation</h2>

<p>The entire Jacques-ID client library is contained in the <span class="tt">jcqid.py</span> module, which has no dependencies beyond the standard library of Python.</p>

<p>The other included scripts are not intended for client use.  A quick summary of their purposes is given below:</p>

<blockquote class="iblock">
<p><span class="tt"><b>check_cycles.py</b></span> — Verify that prime numbers greater than two and less than 2048 will iterate through all values <i>modulo</i> 2048.  See §4.1 <a href="#sec4p1">Regular generation</a> for further information.</p>

<p><span class="tt"><b>parse_primes.py</b></span> — Parse the listing of primes data file.  This module is used by <span class="tt">prime_​table.py</span>.</p>

<p><span class="tt"><b>prime_table.py</b></span> — Use a data file containing prime numbers to generate either the HTML listing of prime numbers used earlier in this document, or a Python list literal that is used both in <span class="tt">check_​cycles.py</span> and <span class="tt">jcqid.py</span>.</p>
</blockquote>

<p>See the documentation within those scripts for further information.  The following subsections document how to use the client library <span class="tt">jcqid.py</span>.</p>

<h3 id="sec5p1">5.1 ID generation</h3>

<p>Each time you want to create a new Jacques-ID, you construct a new instance of the <span class="tt">GenID</span> class:</p>

<blockquote class="cblock">
jcqid.<b>GenID</b>(<br/>
  <i>self,</i><br/>
  force_fallback = False<br/>
)
</blockquote>

<p>By default, the constructed generator object will use the <a href="#sec4p1">regular generation algorithm</a> (§4.1) if possible, falling back to <a href="#sec4p2">fallback generation</a> (§4.2) only if there appears to be something wrong with the system clock.  This is the recommended operation.</p>

<p>If you supply the optional <span class="tt">force_​fallback</span> parameter with a value of <span class="tt">True</span> then the constructed generator object will always use fallback generation.  This is not usually recommended.</p>

<p>Each generator object instance is a single-​use iterator, which means you can use it in a Python <span class="tt">for</span> loop.  Each generator will generate a sequence of 2,048 normalized Jacques-ID strings, with no repeated ID codes within the iteration.  The idea is that you keep iterating until you find an ID code that is unique within your data set.  For example:</p>

<blockquote class="cblock">
<b>import</b> jcqid<br/>
<br/>
<span class="comment"># result will hold the unique ID</span><br/>
result = <b>None</b><br/>
<br/>
<span class="comment"># Try to find a unique ID</span><br/>
<b>for</b> id_code <b>in</b> jcqid.GenID():<br/>
<br/>
  <span class="comment"># Check whether ID is unique within dataset</span><br/>
  <b>if</b> found_unique_id(id_code):<br/>
<br/>
    <span class="comment"># We found a unique ID</span><br/>
    result = id_code<br/>
    <b>break</b><br/>
<br/>
<span class="comment"># Error if we couldn't find unique ID</span><br/>
<b>if</b> result <b>is None</b>:<br/>
  <b>raise</b> GenerateIDError()
</blockquote>

<p>The <span class="tt">found_​unique_​id()</span> function in this example is assumed to be a function defined by the client that queries their dataset to check whether the given Jacques-ID code is used within it.  The <span class="tt">Generate​ID​Error()</span> is assumed to be a client exception that is raised when all 2,048 ID codes generated by the Jacques-ID generator object were already is use in the data set.</p>

<p>Jacques-ID is designed so that the <span class="tt">Generate​ID​Error()</span> exception in the example given above should normally never be thrown.  The only cases it should occur in is if there is something wrong with the system timer, or you are attempting to generate thousands of unique Jacques-ID codes per second.</p>

<p>The Jacques-ID system is not intended for generating thousands of unique IDs per second, and if this is a regular occurence you should use some other ID code system.  However, if you have an exceptional situation in which you suddenly need more than 2,048 IDs to be generated all at once, you have the following options:</p>

<blockquote class="iblock">
<p>(1) Wait for a second or two, generate a batch of a thousand IDs or so using a new generator object instance, wait another second or two, generate another batch of a thousand IDs or so using a new generator object instance, and so forth until all IDs have been generated.  Since the regular generation algorithm changes the time components of the ID each second, waiting a second or two between batches of ID generation will allow you to assign thousands of IDs in a single operation, provided you are willing to wait through the delays.</p>

<p><i><b>Important:</b> If you are using method (1) above, you <b>must</b> use a fresh instance of a generator object for each batch, because the time components are determined at the time of construction of the generator object, <b>not</b> at the time that the ID is generated.  For efficiency, you may reuse the same generator object within each batch to generate IDs, although it is usually recommended that a fresh object instance be used for each ID number to generate.</i></p>

<p>(2) Use the <span class="tt">force_​fallback</span> flag during construction to force fallback mode.  Use each fallback-​mode generator instance for about a thousand or so attempts to generate IDs.  The advantage is you do not need any time delays because fallback generation does not make use of time components.  The disadvantage is that IDs generated in fallback mode can not make guarantees that they will never be generated again in the future.</p>

<p>(3) Assign blocks of IDs using regular generation, but with the time components set to some point in the past for which you know there are no existing IDs.  The Jacques-ID library does not support this, so you would need to write your own routines for generating such IDs.  Also note that this will ruin the Jacques-ID guarantees against ID reuse unless you are very careful about analyzing the situation (which is why this method is not supported in the Jacques-ID library).</p>

<p>(4) Assign blocks of IDs using numeric ID values in regular generation range, but with the <a href="#sec2p3">secound count</a> (§2.3) field in the reserved range of [225, 255].  Such IDs would never be generated by Jacques-ID, but they will pass the <a href="#sec5p3">validation functions</a> (§5.3).  Jacques-ID will never generate such IDs itself, so you would need to write your own routines for generating such IDs.</p>
</blockquote>

<p>The intended use for Jacques-ID is for when you need to generate at most a few hundred IDs per second.  In this case, there should be no problem with running out of ID numbers and no need for the mitigation strategies discussed above.</p>

<h3 id="sec5p2">5.2 ID retirement</h3>

<p>Suppose that you have a Jacques-ID in your dataset that you no longer want to use, and you want to retire it such that it wonʼt be used again in the future.  You can use the following function to retire Jacques-ID codes gracefully:</p>

<blockquote class="cblock">
jcqid.<b>shouldWait</b>(<br/>
  s : str<br/>
) : bool
</blockquote>

<p>This function takes a single string parameter, which must be a normalized Jacques-ID string.  It returns a boolean value that is <span class="tt">True</span> if the client should wait before retiring the ID code, or <span class="tt">False</span> if the client does not need to wait.  The intended use is as follows:</p>

<blockquote class="cblock">
<b>import</b> jcqid<br/>
<b>import</b> time<br/>
<br/>
<span class="comment"># Wait if necessary before retiring code</span><br/>
<b>while</b> jcqid.shouldWait(id_code):<br/>
  time.sleep(1.5)<br/>
<br/>
<span class="comment"># Retire ID code</span><br/>
retire_id(id_code)
</blockquote>

<p>In this example, <span class="tt">id_​code</span> is the Jacques-ID string that will be retired, and <span class="tt">retire_​id()</span> is the client function that retires the ID code from the client data set.</p>

<p>The sleep time does not have to be 1.5 seconds.  You just need to wait until the system timer advances to the next second since the Unix epoch.</p>

<p>The <span class="tt">should​Wait()</span> function checks whether the given ID code is a regularly generated Jacques-ID with a time-​based component.  If it is not — such as a code generated in <a href="#sec4p2">fallback mode</a> (§4.2) — then the function just returns <span class="tt">False</span>.  If the function detects that the ID <i>is</i> a regularly generated ID code with a time-​based component, the function checks whether the time-​based components in the ID match the time-​based components that would be generated at the current system time.  If they do match, the function returns <span class="tt">True</span> indicating that the client should wait.  If they do not match, the function returns <span class="tt">False</span>.</p>

<p>If the system timer is correct and regular generation is used for the ID values, then using the <span class="tt">should​Wait()</span> function will guarantee that a retired ID code will not be reused in the future.</p>

<p>Note that if you are retiring a block of ID codes, it is feasible to do a <span class="tt">should​Wait()</span> loop on all of them.  If a wait loop is actually necessary for any of the codes, the first wait loop should cause all the rest of the IDs to not require one because time should have advanced past the time components in all the rest of the IDs, too.</p>

<h3 id="sec5p3">5.3 ID handling</h3>

<p>To normalize a string containing a Jacques-ID, use the following function:</p>

<blockquote class="cblock">
jcqid.<b>norm</b>(<br/>
  s : str | <i>mixed</i><br/>
) : str | None
</blockquote>

<p>The function returns either a normalized Jacques-ID string, or <span class="tt">None</span> if the given value was not a string or did not contain a valid Jacques-ID.</p>

<p>Normalization begins by trimming leading and trailing whitespace.  Then, it converts any URL-​safe base-64 digits to their standard equivalents.  If the result after these transformations is exactly eight base-64 digits, then this normalized value is returned.  Otherwise, <span class="tt">None</span> is returned.  See §3 <a href="#sec3">ID format</a> for further information about the ID format.</p>

<p>To check whether a given value is a string that contains a normalized Jacques-ID, use the following function:</p>

<blockquote class="cblock">
jcqid.<b>isNorm</b>(<br/>
  s : str | <i>mixed</i><br/>
) : bool
</blockquote>

<p>The function returns <span class="tt">True</span> only if the given parameter is a string containing exactly eight base-64 digits that use the standard symbol-​digits and have no padding.  In all other cases, it returns <span class="tt">False</span>.</p>

<p>Results from the <span class="tt">norm()</span> function that are not <span class="tt">None</span> will always pass <span class="tt">is​Norm()</span>.</p>

<p>Note that some of the IDs that <span class="tt">is​Norm()</span> validates are actually impossible to generate with Jacques-ID.  Specifically, regularly generated ID codes that have a <a href="#sec2p3">second count</a> (§2.3) in reserved range [225, 255] will pass <span class="tt">is​Norm()</span>, even though they are never generated by Jacques-ID.</p>

<p>If you need to pass a Jacques-ID in an environment where the <span class="tt">+</span> or <span class="tt">/</span> symbols might be a problem (such as an URL), you can use the following function:</p>

<blockquote class="cblock">
jcqid.<b>urlForm</b>(<br/>
  s : str | <i>mixed</i><br/>
) : str | None
</blockquote>

<p>This function first calls the <span class="tt">norm()</span> function to normalize the string as a Jacques-ID.  If this normalization call fails, then this function returns <span class="tt">None</span> indicating that formatting failed.  Otherwise, this function takes the normalized string and replaces the <span class="tt">+</span> and <span class="tt">/</span> digits with their URL-​safe equivalents <span class="tt">-</span> and <span class="tt">_</span></p>

<p>The resulting string from this function will <b>not</b> pass <span class="tt">is​Norm()</span>, but it can be passed through the <span class="tt">norm()</span> function to get back the normalized Jacques-ID string.</p>

<hr/>

<h2 id="secA">A. External references</h2>

<p id="extArith">[ARITH] — “Fundamental Theorem of Arithmetic”<br/>
Wolfram MathWorld<br/>
<a href="https://mathworld.wolfram.com/FundamentalTheoremofArithmetic.html">https://mathworld.wolfram.com/FundamentalTheoremofArithmetic.html</a></p>

<p id="extBark">[BARK] — Bark project<br/>
Canidtech<br/>
<a href="https://www.purl.org/canidtech/r/bark">https://www.purl.org/canidtech/r/bark</a></p>

<p id="extP2038">[P-2038] — “The Project 2038 Frequently Asked Questions (FAQ)”<br/>
<a href="http://maul.deepsky.com/~merovech/2038.html">http://maul.deepsky.com/~merovech/2038.html</a></p>

<p id="extPrimes">[PRIMES] — “PrimePages: prime number research &amp; records”<br/>
Chris K. Caldwell, University Tennessee at Martin<br/>
<a href="https://primes.utm.edu/">https://primes.utm.edu/</a></p>

<h2 id="secB">B. Building the specification</h2>

<p>The HTML source code of this specification is auto-generated by <a href="#extBark">[BARK]</a> from the <a href="jcqid.html.bark">jcqid.html.bark</a> source file.  Changes should be made to the Bark source file, which should then be recompiled with Bark, instead of directly modifying the HTML code.</p>

<p>The webfonts used to render this specification are included in the <span class="tt">fonts</span> subdirectory.  Please see the <a href="fonts/README.txt">README</a> file in that subdirectory for further information about the webfonts and their licenses.</p>

<h2 id="secC">C. Specification license</h2>

<div>
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />Jacques-ID Specification by Multimedia Data Technology Inc is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br />Permissions beyond the scope of this license may be available at <a href="https://www.canidtech.com/">https://www.canidtech.com/</a>.
</div>

<hr/>
<div id="footline">
Multimedia Data Technology, Inc.<br/>
<a href="https://www.canidtech.com/">www.canidtech.com</a><br/>
<br/>
Written by Noah Johnson<br/>
<span class="tt">noah.johnson@loupmail.com</span><br/>
<br/>
May 2021
</div>

  </body>
</html>
