#
# jcqid.py
# ========
#

"""
Python-3 module for generating and handling Jacques-ID identification
codes.

All exceptions generated by this module are subclasses of JCQIDError and
overload the str operator so that they can be printed as user-friendly
error messages.  The messages have punctuation at the end, but they do
NOT have a line break at the end.

For further information, see the Jacques-ID specification.
"""

import base64
import datetime
import random

#
# Module exports
# --------------
#

__all__ = [
  'JCQIDError',
  'ParamError',
  'GenID',
  'isNorm',
  'norm',
  'urlForm',
  'shouldWait'
]

#
# Exceptions
# ----------
#

class JCQIDError(Exception):
  def __str__(self):
    return 'Unknown error in Jacques-ID module!'

class ParamError(JCQIDError):
  def __str__(self):
    return 'Invalid parameter in call to Jacques-ID module!'

#
# Table of primes
# ---------------
#
# All the prime numbers that are greater than 2 and less than 2048.
#
# This list was auto-generated by the prime_table.py utility script.
#
primes = [
  3, 5, 7, 11, 13, 17, 19, 23, 29, 31,
  37, 41, 43, 47, 53, 59, 61, 67, 71, 73,
  79, 83, 89, 97, 101, 103, 107, 109, 113, 127,
  131, 137, 139, 149, 151, 157, 163, 167, 173, 179,
  181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
  239, 241, 251, 257, 263, 269, 271, 277, 281, 283,
  293, 307, 311, 313, 317, 331, 337, 347, 349, 353,
  359, 367, 373, 379, 383, 389, 397, 401, 409, 419,
  421, 431, 433, 439, 443, 449, 457, 461, 463, 467,
  479, 487, 491, 499, 503, 509, 521, 523, 541, 547,
  557, 563, 569, 571, 577, 587, 593, 599, 601, 607,
  613, 617, 619, 631, 641, 643, 647, 653, 659, 661,
  673, 677, 683, 691, 701, 709, 719, 727, 733, 739,
  743, 751, 757, 761, 769, 773, 787, 797, 809, 811,
  821, 823, 827, 829, 839, 853, 857, 859, 863, 877,
  881, 883, 887, 907, 911, 919, 929, 937, 941, 947,
  953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019,
  1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087,
  1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153,
  1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229,
  1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297,
  1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381,
  1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453,
  1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523,
  1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597,
  1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663,
  1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741,
  1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823,
  1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901,
  1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993,
  1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039
]

#
# Random number generation
# ------------------------
#
# Set the global rgen to a random number generator object and define the
# function rgen_range() to randomly select an integer in a given range
# using the rgen generator, rgen_sample() to randomly select 2048 unique
# values from the reserved hour count range (for use in fallback
# generation), and rgen_prime() to randomly select a prime number from
# the primes list defined earlier in this module.
#
# This module will attempt to use random.SystemRandom() as the random
# number generator, which is based on os.urandom(), which is based on
# the operating system's secure random number generator, if possible.
# If that doesn't work, this module will fall back to using the standard
# random.Random generator, which is based on the current system time.
#

# Begin with random number generator set to None
#
rgen = None

# Attempt to get the system random number generator
#
try:
  rgen = random.SystemRandom()
except:
  rgen = None

# If we didn't get the system random number generator, fall back to
# using the regular random number generator seeded with the current
# time
#
if rgen is None:
  rgen = random.Random(None)

def rgen_range(a, b):
  """
  Generate a random number in range [a, b].
  
  This is a wrapper around the random.randint() function that redirects
  the call to the random number generator chosen by this module.
  
  Parameters:
  
    a : int - the lower bound (inclusive) of the random range
    
    b : int - the upper bound (inclusive) of the random range
    
  Return:
  
    a randomly selected integer in range [a, b]
  """
  global rgen
  return rgen.randint(a, b)

def rgen_sample():
  """
  Return a list of 2048 randomly selected values from the reserved hour
  count range.

  The return value will always be a list of 2048 integers, where each
  integer is in range [0, 262967] and each integer is unique within the
  list.  Selected integers are not sorted in any manner within the list.
 
  Return:

    a randomly sampled list
  """
  global rgen
  return rgen.sample(range(262968), 2048)

def rgen_prime():
  """
  Return a randomly selected prime number that is greater than 2 and
  less than 2048.
 
  Return:
 
    a randomly selected prime in range [3, 2047]
  """
  global rgen, primes
  return rgen.choice(primes)

# Test random number generation; if it doesn't work, then set the random
# number generator to the regular random number generator seeded with
# the current time
#
test_val = None
try:
  test_val = rgen_range(0, 2047)
  test_val = rgen_sample()
  test_val = rgen_prime()
except:
  rgen = random.Random(None)
finally:
  del test_val

#
# Timestamp generation
# --------------------
#

def timestamp():
  """
  Attempt to generate the current, checked timestamp from the system
  timer.
 
  This uses the datetime module to get the current time in UTC and then
  convert this into a POSIX time value, which counts the number of
  seconds that have elapsed since midnight GMT at the start of Jan 1,
  1970.
 
  The function then computes the number of hours that have elapsed since
  that Unix epoch.  If this number of hours is less than 262,968 (which
  implies the year is before Gregorian year 2000) or the number of hours
  is greater than 0x1ffffff (which implies the year is 5797 or beyond),
  then the function assumes that something is wrong with the system
  timer and returns None instead.
 
  This function therefore guarantees that the return value will either
  be an timestamp in range [262968 * 3600, 0x1ffffff * 3600] that
  represents the current time as the number of seconds since the Unix
  epoch, or it is None, indicating a problem with the system timer.
 
  Return:
 
    the current timestamp in seconds or None
  """
  
  # Get the number of seconds since the Unix epoch
  ts = int(datetime.datetime.now(datetime.timezone.utc).timestamp())

  # Get the hour count
  hc = ts // 3600
  
  # If the hour count indicates the current time is less than the year
  # 2000, or the hour count would overflow 25-bit range (implying the
  # year is 5797 or beyond), assume the system timer isn't working
  # correctly and set ts to None
  if (hc < 262968) or (hc > 0x1ffffff):
    ts = None

  # Return the timestamp or None
  return ts

#
# Local functions
# ---------------
#

def tsToVal(i):
  """
  Convert a timestamp value to the 37 least significant bits in the
  numeric value of a Jacques-ID code.
 
  The given value must be an integer in range such that the hour count
  is within [262968, 0x1ffffff].
  
  Parameters:
 
    i : int - the timestamp value to convert
 
  Return:
 
    the numeric value for the 37 least significant bits of the ID code
  """
  
  # Check parameter
  if not isinstance(i, int):
    raise ParamError()
  if i < 0:
    raise ParamError()
  
  # Compute hour count, update i to remove hours, and check range
  hc = i // 3600
  i = i % 3600
  if (hc < 262968) or (hc > 0x1ffffff):
    raise ParamError()
  
  # Compute division count and update i to remove divisions
  dc = i // 225
  i = i % 225
  
  # The remaining i is the seconds count, so we can now return the whole
  # thing
  return (i << 29) + (dc << 25) + hc

#
# Generator object
# ----------------
#

class GenID:
  """
  Construct an instance of this object to generate a sequence of ID
  codes based on the current time until you find a unique one.
  """
  
  def __init__(self, force_fallback=False):
    """
    Construct a new ID generator object.
   
    You should construct a new generator object instance for each new ID
    that you want to find.
   
    A generator object is used instead of just a function because you
    may need to make multiple attempts to find an ID that is unique.
    The generator generates IDs in a special fashion to reduce the
    possibility of collisions.  See the Jacques-ID specification for
    further information about the process.
   
    The constructor will use the current time from the system clock to
    initialize the time-specific fields of the generator object.  Note
    that the exact time an ID was generated can be derived from the ID
    value.
   
    If the optional force_fallback flag is set to True, then the
    constructed generator will be in fallback mode even if regular mode
    could have been used.  The default is to use regular mode whenever
    possible, which is usually what you want.
   
    Parameters:
   
      force_fallback : bool - (optional) if this parameter is set to
      True, then the constructed instance will be forced into fallback
      mode
    """
    
    # Check optional parameter
    if not isinstance(force_fallback, bool):
      raise ParamError()
    
    # Begin with timestamp set to None
    ts = None
    
    # If we are not forcing fallback mode, attempt to get the current
    # timestamp
    if not force_fallback:
      ts = timestamp()
    
    # Set up the instance either in regular mode or fallback mode
    if ts is not None:
      # Set up instance for regular mode
      self.fallback = False
      self.gencount = 0
      self.psel = rgen_prime()
      self.nextval = rgen_range(0, 2047)
      self.basebits = tsToVal(ts)
      
    else:
      # Set up instance for fallback mode
      self.fallback = True
      self.gencount = 0
      self.harray = rgen_sample()

  def nextID(self):
    """
    Generate the next Jacques-ID with this generator object.
   
    Each call to this function generates a new ID that has never been
    generated before by this object instance.
   
    This can be called up to 2,048 times for each object instance.
    After that, further calls to the function always return None.
   
    The current time is read during generator object construction and
    NOT during this call, so waiting before calling this function again
    will have no impact on the time-specific components of the generated
    IDs.  You have to construct a new object instance to get new
    time-specific values.
   
    In regular mode, IDs generated during one second of Unix epoch time
    will never again be generated in subsequent seconds of Unix epoch
    time.
   
    The return value always passes the isNorm() function, meaning that
    the return value is always a normalized Jacques-ID string.
   
    Return:
   
      a newly generated Jacques-ID code string, or None if this
      generator object is not able to generate any further codes
    """
    
    # If we have exhausted all IDs we can generate, return None
    if self.gencount >= 2048:
      return None
    
    # Determine which generation algorithm to use and use it to generate
    # the numeric value of the ID
    result = None
    if self.fallback:
      # Fallback generation mode, so generate 23 random bits
      rb = rgen_range(0, 0x7fffff)
      
      # Combine with the randomly chosen hour count to get the numeric
      # value of the ID
      result = (rb << 25) + self.harray[self.gencount]
      
    else:
      # Regular generation mode, so combine nextval with basebits to get
      # the numeric value of the ID
      result = (self.nextval << 37) + self.basebits
      
      # Update nextval
      self.nextval = (self.nextval + self.psel) % 2048
    
    # We got the numeric value of the 48-bit ID, so convert it to six
    # bytes in big endian order
    result = result.to_bytes(6, byteorder='big')
    
    # We can now encode in base-64 for the final ID value
    result = base64.b64encode(result)
    
    # Convert bytes to string
    result = result.decode(encoding='utf-8')
    
    # Increment count of generated IDs
    self.gencount = self.gencount + 1
    
    # Return result
    return result

#
# Public functions
# ----------------
#

def isNorm(s):
  """
  Check whether a given value is a normalized Jacques-ID string.
 
  The given value must be a string of exactly eight characters, and each
  of those characters must be a non-padding base-64 digit with the only
  non-alphanumeric symbols being + and /
 
  Parameters:
 
    s : str | mixed - the value to check
 
  Return:
 
    True if value is a normalized Jacques-ID string, False otherwise
 
  """
  
  # Check type
  if not isinstance(s, str):
    return False
  
  # Check length
  if len(s) != 8:
    return False
  
  # Check each character
  for cc in s:
    # Get character code
    c = ord(cc)
    
    # Check character code range
    if ((c < ord('A')) or (c > ord('Z'))) and \
        ((c < ord('a')) or (c > ord('z'))) and \
        ((c < ord('0')) or (c > ord('9'))) and \
        (c != ord('+')) and (c != ord('/')):
      return False
  
  # If we got here, the check passes
  return True

def norm(s):
  """
  Normalize the given Jacques-ID string.
 
  The return value always passes isNorm().  If the given value is not a
  string or it can't be normalized properly, then None is returned.
 
  Normalization trims leading and trailing whitespace, and converts the
  URL-safe base-64 digits "-" and "_" to their standard equivalents "+"
  and "/"
 
  The result must pass isNorm() or None will be returned.
 
  Parameters:
 
    s : str | mixed - the value to normalize
 
  Return:
 
    the normalized Jacques-ID string, or None if normalization failed
  """
  
  # Check type
  if not isinstance(s, str):
    return None
  
  # Drop trailing and leading whitespace
  s = s.strip()
  
  # Convert URL-safe digits
  s = s.replace('-', '+')
  s = s.replace('_', '/')
  
  # Check whether now properly normalized
  if not isNorm(s):
    s = None
  
  # Return result
  return s

def urlForm(s):
  """
  Normalize a given Jacques-ID string and then convert it to URL-safe
  format.
 
  The return value can always be successfully normalized back into
  standard form using norm().  If the given parameter value is not a
  string or it can't be normalized properly, then None is returned.
 
  This function simply calls norm() to perform regular normalization,
  and then, if the return is not None, it replaces + and / with - and _
 
  Parameters:
 
    s : str | mixed - the value to normalize and convert to URL-safe
 
  Return:
 
    the URL-safe Jacques-ID string, or None if normalization failed
  """
  
  # Attempt regular normalization
  s = norm(s)
  
  # If normalization succeeded, perform replacements
  if s is not None:
    s = s.replace('+', '-')
    s = s.replace('/', '_')
  
  # Return result
  return s

def shouldWait(s):
  """
  Given a Jacques-ID string, determine whether the client should wait a
  second or two before deleting the ID to make sure it can't get reused.
 
  The given ID must pass isNorm() or an exception occurs.
 
  The guarantee that the ID won't be used can only be made for IDs
  generated with the regular algorithm rather than the fallback
  algorithm, AND the system clock must be kept accurate.
 
  This function decodes the numeric ID value embedded in the ID string
  and first checks to see whether the numeric value is a fallback value
  or a regular value.  If it is a fallback value, this function returns
  False and proceeds no further in processing since waiting has no
  effect on fallback values.
 
  Otherwise, if the numeric ID value is a regularly generated value,
  this function masks out the random portion and checks whether the
  time-specific fields are equal to the current time.  If they are, the
  function returns True, indicating the client should wait a second or
  two.  Otherwise, the function returns False.
  
  Parameters:
 
    s : str - the normalized Jacques-ID to check
 
  Return:
 
    True if client should wait a second or two before deleting, False
    if no wait is necessary
  """
  
  # Check parameter
  if not isNorm(s):
    raise ParamError()
  
  # Encode the ID string into bytes
  s = s.encode(encoding='utf-8')
  
  # Decode the base-64 bytes into binary bytes
  s = base64.b64decode(s)
  
  # Decode the numeric value of the ID from the binary bytes
  i = int.from_bytes(s, byteorder='big')
  
  # Mask out the random portion of the ID
  i = i & 0x1fffffffff
  
  # Determine current time-based portion of ID, or return False if can't
  # read system time
  t = timestamp()
  if t is None:
    return False
  
  # Check whether time-based portion of given ID matches current time
  # and return True if it does, False in all other cases
  if tsToVal(t) == i:
    return True
  else:
    return False
